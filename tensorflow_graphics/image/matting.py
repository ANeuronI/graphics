#Copyright 2018 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""This module implements image matting functionalities."""

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function

import numpy as np
import tensorflow as tf

from tensorflow_graphics.util import asserts
from tensorflow_graphics.util import export_api
from tensorflow_graphics.util import shape


def _quadratic_form(matrix, vector):
  """Computes the quadratic form between a matrix and a vector.

  The quadratic form between a matrix A and a vector x can be written as
  Q(x) = <x,Ax>, where <.,.> is the dot product operator.

  Note:
    In the following, A1 to An are optional batch dimensions.

  Args:
    matrix: A tensor of shape `[A1, ..., An, C, C]`.
    vector: A tensor of shape `[A1, ..., An, 1, C]`.

  Returns:
    A tensor of shape `[A1, ..., An, 1]`.
  """
  vector_matrix = tf.matmul(vector, matrix)
  vector_matrix_vector = tf.matmul(vector_matrix, vector, transpose_b=True)
  return vector_matrix_vector


def _image_patches(image, size):
  """Extracts square image patches.

  Args:
    image: A tensor of shape `[B, H, W, C]`.
    size: The size of the square patches.

  Returns:
    A tensor of shape `[B, H, W, C * size^2]`.
  """
  return tf.image.extract_patches(
      image,
      sizes=[1, size, size, 1],
      strides=[1, 1, 1, 1],
      rates=[1, 1, 1, 1],
      padding="VALID")


def laplacian_weights(image, size=3, eps=1e-5, name=None):
  """Generates the closed form matting Laplacian weights.

  Generates the closed form matting Laplacian weights as proposed by Levin et
  al. in "A Closed Form Solution to Natural Image Matting".

  Args:
    image: A tensor of shape `[B, H, W, C]`.
    size: An `int` representing the size of the patches used to enforce
      smoothness.
    eps: A small number of type `float` to regularize the problem.
    name: A name for this op. Defaults to "matting_laplacian_weights".

  Returns:
    A tensor of shape `[B, H, W, size^2, size^2]` containing the
    matting Laplacian weights .

  Raises:
    ValueError: If `image` is not of rank 4.
  """
  with tf.compat.v1.name_scope(name, "matting_laplacian_weights", [image]):
    image = tf.convert_to_tensor(value=image)

    shape.check_static(image, has_rank=4)

    pixels = size**2
    channels = tf.shape(input=image)[3]
    dtype = image.dtype
    patches = _image_patches(image, size)
    current_shape = tf.shape(input=patches)
    new_shape = tf.concat((current_shape[:-1], (pixels, channels)), axis=-1)
    patches = tf.reshape(patches, shape=new_shape)
    mean = tf.reduce_mean(input_tensor=patches, axis=-2, keepdims=True)
    demean = patches - mean
    covariance = tf.matmul(demean, demean, transpose_a=True) / pixels
    regularizer = (eps / pixels) * tf.eye(channels, dtype=dtype)
    covariance_inv = tf.linalg.inv(covariance + regularizer)
    covariance_inv = asserts.assert_no_infs_or_nans(covariance_inv)
    mat = _quadratic_form(covariance_inv, demean)
    return tf.eye(pixels, dtype=dtype) - (1.0 + mat) / pixels


def loss(matte, weights, name=None):
  """Computes the matting loss function based on the matting Laplacian weights.

  Computes the matting loss function based on the `weights` generated by the
  `laplacian_weights` function which implements the approach proposed by Levin
  et al. in "A Closed Form Solution to Natural Image Matting".

  Args:
    matte: A tensor of shape `[B, H, W, 1]`.
    weights: A tensor containing the Laplacian weights computed by the
      `laplacian_weights` function.
    name: A name for this op. Defaults to "matting_loss".

  Returns:
    A tensor containing a scalar value defining the matting loss.

  Raises:
    ValueError: If the last dimension of `matte` is not 1. If `matte` is not
    of rank 4. If the last two dimensions of `weights` are not of the
    same size. If `weights` is not of rank 5. If `B` is different
    between `matte` and `weights`.
  """
  with tf.compat.v1.name_scope(name, "matting_loss", [matte, weights]):
    matte = tf.convert_to_tensor(value=matte)
    weights = tf.convert_to_tensor(value=weights)

    pixels = tf.compat.dimension_value(weights.shape[-1])
    shape.check_static(matte, has_rank=4, has_dim_equals=(-1, 1))
    shape.check_static(weights, has_rank=5, has_dim_equals=(-2, pixels))
    shape.compare_batch_dimensions(
        tensors=(matte, weights), last_axes=0, broadcast_compatible=False)

    size = np.sqrt(pixels)
    patches = tf.expand_dims(_image_patches(matte, size), axis=-2)
    losses = _quadratic_form(weights, patches)
    return tf.reduce_mean(input_tensor=losses)


# API contains all public functions and classes.
__all__ = export_api.get_functions_and_classes()
